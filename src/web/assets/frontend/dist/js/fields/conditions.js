/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/fields/conditions.js":
/*!*************************************!*\
  !*** ./src/js/fields/conditions.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormieConditions\": () => (/* binding */ FormieConditions)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ \"./src/js/utils/utils.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\nvar FormieConditions = /*#__PURE__*/function () {\n  function FormieConditions() {\n    var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, FormieConditions);\n\n    this.$form = settings.$form;\n    this.form = this.$form.form; // Best-practice for storing data keyed by DOM nodes\n    // https://fitzgeraldnick.com/2014/01/13/hiding-implementation-details-with-e6-weakmaps.html\n\n    this.conditionsStore = new WeakMap();\n    this.initFieldConditions();\n  }\n\n  _createClass(FormieConditions, [{\n    key: \"initFieldConditions\",\n    value: function initFieldConditions() {\n      var _this = this;\n\n      this.$form.querySelectorAll('[data-field-conditions]').forEach(function ($field) {\n        var conditionSettings = _this.parseJsonConditions($field);\n\n        if (!conditionSettings || !conditionSettings.conditions.length) {\n          return;\n        } // Store the conditions against the target field object for later access/testing\n\n\n        var conditions = [];\n        conditionSettings.conditions.forEach(function (condition) {\n          // Get the field(s) we're targeting to watch for changes. Note we need to handle multiple fields (checkboxes)\n          var $targets = _this.$form.querySelectorAll('[name=\"' + condition.field + '\"]'); // Check if we're dealing with multiple fields, like checkboxes. This overrides the above\n\n\n          var $multiFields = _this.$form.querySelectorAll('[name=\"' + condition.field + '[]\"]');\n\n          if ($multiFields.length) {\n            $targets = $multiFields;\n          } // Special handling for Repeater/Groups that have `new1` in their name but for page reload forms\n          // this will be replaced by the blockId, and will fail to match the conditions settings.\n\n\n          if ((!$targets || !$targets.length) && condition.field.includes('[new1]')) {\n            // Get tricky with Regex. Find the element that matches everything except `[new1]` for `[1234]`.\n            // Escape special characters `[]` in the string, and swap `[new1]` with `[\\d+]`.\n            var regexString = condition.field.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&').replace(/new1/g, '\\\\d+'); // Find all targets via Regex.\n\n            $targets = _this.querySelectorAllRegex(new RegExp(regexString), 'name');\n          }\n\n          if (!$targets || !$targets.length) {\n            return;\n          } // Store the conditions with the target field for later access/testing\n\n\n          condition.$targets = $targets;\n          conditions.push(condition);\n          $targets.forEach(function ($target) {\n            // Get the right event for the field\n            var eventType = _this.getEventType($target); // Watch for changes on the target field. When one occurs, fire off a custom event on the source field\n            // We need to do this because target fields can be targetted by multiple conditions, and source\n            // fields can have multiple conditions - we need to check them all for all/any logic.\n\n\n            _this.form.addEventListener($target, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.eventKey)(eventType), function () {\n              return $field.dispatchEvent(new CustomEvent('onFormieEvaluateConditions', {\n                bubbles: true\n              }));\n            });\n          });\n        }); // Save our condition settings and targets against the origin fields. We'll use this to evaluate conditions\n\n        _this.conditionsStore.set($field, {\n          showRule: conditionSettings.showRule,\n          conditionRule: conditionSettings.conditionRule,\n          isNested: conditionSettings.isNested || false,\n          conditions: conditions\n        }); // Add a custom event listener to fire when the field event listener fires\n\n\n        _this.form.addEventListener($field, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.eventKey)('onFormieEvaluateConditions'), _this.evaluateConditions.bind(_this)); // Also - trigger the event right now to evaluate immediately. Namely if we need to hide\n        // field that are set to show if conditions are met. Pass in a param to let fields know if this is \"init\".\n\n\n        $field.dispatchEvent(new CustomEvent('onFormieEvaluateConditions', {\n          bubbles: true,\n          detail: {\n            init: true\n          }\n        }));\n      }); // Update the form hash, so we don't get change warnings\n\n      if (this.form.formTheme) {\n        this.form.formTheme.updateFormHash();\n      }\n    }\n  }, {\n    key: \"evaluateConditions\",\n    value: function evaluateConditions(e) {\n      var _this2 = this;\n\n      var $field = e.target;\n      var isInit = e.detail ? e.detail.init : false; // Get the prepped conditions for this field\n\n      var conditionSettings = this.conditionsStore.get($field);\n\n      if (!conditionSettings) {\n        return;\n      }\n\n      var showRule = conditionSettings.showRule,\n          conditionRule = conditionSettings.conditionRule,\n          conditions = conditionSettings.conditions,\n          isNested = conditionSettings.isNested;\n      var results = {};\n      conditions.forEach(function (condition, i) {\n        var logic = condition.condition,\n            value = condition.value,\n            $targets = condition.$targets,\n            field = condition.field; // We're always dealing with a collection of targets, even if the target is a text field\n        // The reason being is this normalises behaviour for some fields (checkbox/radio) that\n        // have multiple fields in a group.\n\n        $targets.forEach(function ($target) {\n          var result = false;\n          var testOptions = {};\n          var tagName = $target.tagName.toLowerCase();\n          var inputType = $target.getAttribute('type') ? $target.getAttribute('type').toLowerCase() : ''; // Create a key for this condition rule that we'll use to store (potentially multiple) results against.\n          // It's not visibly needed for anything, but using the target's field name helps with debugging.\n\n          var resultKey = field + '_' + i; // Store all results as an array, and we'll normalise afterwards. Group results by their condition rule.\n          // For example: { dropdown_0: [false], radio_1: [true, false] }\n\n          if (!results[resultKey]) {\n            results[resultKey] = [];\n          } // Handle some special options like dates - tell our condition tester about them\n\n\n          if (inputType === 'date') {\n            testOptions.isDate = true;\n          } // Handle agree fields, which are a single checkbox, checked/unchecked\n\n\n          if ($target.getAttribute('data-fui-input-type') === 'agree') {\n            // Ignore the empty, hidden checkbox\n            if (inputType === 'hidden') {\n              return;\n            } // Convert the value to boolean to compare\n\n\n            result = _this2.testCondition(logic, value == '0' ? false : true, $target.checked);\n            results[resultKey].push(result);\n          } else if (inputType === 'checkbox' || inputType === 'radio') {\n            // Handle (multi) checkboxes and radio, which are a bit of a pain\n            result = _this2.testCondition(logic, value, $target.value) && $target.checked;\n            results[resultKey].push(result);\n          } else if (tagName === 'select' && $target.hasAttribute('multiple')) {\n            // Handle multi-selects\n            Array.from($target.options).forEach(function ($option) {\n              result = _this2.testCondition(logic, value, $option.value) && $option.selected;\n              results[resultKey].push(result);\n            });\n          } else {\n            result = _this2.testCondition(logic, value, $target.value, testOptions);\n            results[resultKey].push(result);\n          }\n        });\n      }); // Normalise the results before going further, as this'll be keyed as an object, so convert to an array\n      // and because we can have multiple inputs, each with their own value, reduce them to a single boolean.\n      // For example: { dropdown_0: [false], radio_1: [true, false] } changes to [false, true].\n\n      var normalisedResults = [];\n      Object.values(results).forEach(function (result) {\n        normalisedResults.push(result.includes(true));\n      });\n      var finalResult = false; // Check to see how to compare the result (any or all).\n\n      if (normalisedResults.length) {\n        if (conditionRule === 'all') {\n          // Are _all_ the conditions the same?\n          finalResult = normalisedResults.every(function (val) {\n            return val === true;\n          });\n        } else {\n          finalResult = normalisedResults.includes(true);\n        }\n      } // Check if this condition is nested in a Group/Repeater field. Only proceed if the parent field\n      // conditional evaluation has passed.\n\n\n      var overrideResult = false; // But *do* setup conditions on the first run, when initialising all the fields\n\n      if (isNested && !isInit) {\n        var $parentField = $field.closest('.fui-type-group, .fui-type-repeater');\n\n        if ($parentField) {\n          // Is the parent field conditionally hidden? Force the evaluation to be true (this field is\n          // is conditionallu hidden), to prevent inner field conditions having a higher priority than the\n          // parent Group/Repeater fields.\n          if ($parentField.conditionallyHidden) {\n            overrideResult = true;\n          }\n        }\n      } // Show or hide? Also toggle the disabled state to sort out any hidden required fields\n\n\n      if (overrideResult || finalResult && showRule !== 'show' || !finalResult && showRule === 'show') {\n        $field.conditionallyHidden = true;\n        $field.setAttribute('data-conditionally-hidden', true);\n        $field.querySelectorAll('input, textarea, select').forEach(function ($input) {\n          $input.setAttribute('disabled', true);\n        });\n      } else {\n        $field.conditionallyHidden = false;\n        $field.removeAttribute('data-conditionally-hidden');\n        $field.querySelectorAll('input, textarea, select').forEach(function ($input) {\n          $input.removeAttribute('disabled');\n        });\n      } // Fire an event to notify that the field's conditions have been evaluated\n\n\n      $field.dispatchEvent(new CustomEvent('onAfterFormieEvaluateConditions', {\n        bubbles: true,\n        detail: {\n          init: isInit\n        }\n      }));\n    }\n  }, {\n    key: \"parseJsonConditions\",\n    value: function parseJsonConditions($field) {\n      var json = $field.getAttribute('data-field-conditions');\n\n      if (json) {\n        try {\n          return JSON.parse(json);\n        } catch (e) {\n          console.error('Unable to parse JSON conditions: ' + e);\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getEventType\",\n    value: function getEventType($field) {\n      var tagName = $field.tagName.toLowerCase();\n      var inputType = $field.getAttribute('type') ? $field.getAttribute('type').toLowerCase() : '';\n\n      if (tagName === 'select' || inputType === 'date') {\n        return 'change';\n      }\n\n      if (inputType === 'number') {\n        return 'input';\n      }\n\n      if (inputType === 'checkbox' || inputType === 'radio') {\n        return 'click';\n      }\n\n      return 'keyup';\n    }\n  }, {\n    key: \"testCondition\",\n    value: function testCondition(logic, value, fieldValue) {\n      var testOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var result = false; // Are we dealing with dates? That's a whole other mess...\n\n      if (testOptions.isDate) {\n        value = new Date(value).valueOf();\n        fieldValue = new Date(fieldValue).valueOf();\n      }\n\n      if (logic === '=') {\n        result = value === fieldValue;\n      } else if (logic === '!=') {\n        result = value !== fieldValue;\n      } else if (logic === '>') {\n        result = parseFloat(fieldValue, 10) > parseFloat(value, 10);\n      } else if (logic === '<') {\n        result = parseFloat(fieldValue, 10) < parseFloat(value, 10);\n      } else if (logic === 'contains') {\n        result = fieldValue.includes(value);\n      } else if (logic === 'startsWith') {\n        result = fieldValue.startsWith(value);\n      } else if (logic === 'endsWith') {\n        result = fieldValue.endsWith(value);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"querySelectorAllRegex\",\n    value: function querySelectorAllRegex(regex, attributeToSearch) {\n      var output = [];\n\n      var _iterator = _createForOfIteratorHelper(this.$form.querySelectorAll(\"[\".concat(attributeToSearch, \"]\"))),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var element = _step.value;\n\n          if (regex.test(element.getAttribute(attributeToSearch))) {\n            output.push(element);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return output;\n    }\n  }]);\n\n  return FormieConditions;\n}();\nwindow.FormieConditions = FormieConditions;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE9BQU9DLE1BQVA7SUFDSDtFQXJSTDtJQUFBO0lBQUEsT0F1UkksK0JBQXNCd0MsS0FBdEIsRUFBNkJDLGlCQUE3QixFQUFnRDtNQUM1QyxJQUFNQyxNQUFNLEdBQUcsRUFBZjs7TUFENEMsMkNBR3hCLEtBQUt6RixLQUFMLENBQVdLLGdCQUFYLFlBQWdDbUYsaUJBQWhDLE9BSHdCO01BQUE7O01BQUE7UUFHNUMsb0RBQTJFO1VBQUEsSUFBbEVFLE9BQWtFOztVQUN2RSxJQUFJSCxLQUFLLENBQUNJLElBQU4sQ0FBV0QsT0FBTyxDQUFDdEMsWUFBUixDQUFxQm9DLGlCQUFyQixDQUFYLENBQUosRUFBeUQ7WUFDckRDLE1BQU0sQ0FBQ3BFLElBQVAsQ0FBWXFFLE9BQVo7VUFDSDtRQUNKO01BUDJDO1FBQUE7TUFBQTtRQUFBO01BQUE7O01BUzVDLE9BQU9ELE1BQVA7SUFDSDtFQWpTTDs7RUFBQTtBQUFBO0FBb1NBRyxNQUFNLENBQUM5RixnQkFBUCxHQUEwQkEsZ0JBQTFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2ZpZWxkcy9jb25kaXRpb25zLmpzPzI5ZTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXZlbnRLZXkgfSBmcm9tICcuLi91dGlscy91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBGb3JtaWVDb25kaXRpb25zIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9KSB7XG4gICAgICAgIHRoaXMuJGZvcm0gPSBzZXR0aW5ncy4kZm9ybTtcbiAgICAgICAgdGhpcy5mb3JtID0gdGhpcy4kZm9ybS5mb3JtO1xuXG4gICAgICAgIC8vIEJlc3QtcHJhY3RpY2UgZm9yIHN0b3JpbmcgZGF0YSBrZXllZCBieSBET00gbm9kZXNcbiAgICAgICAgLy8gaHR0cHM6Ly9maXR6Z2VyYWxkbmljay5jb20vMjAxNC8wMS8xMy9oaWRpbmctaW1wbGVtZW50YXRpb24tZGV0YWlscy13aXRoLWU2LXdlYWttYXBzLmh0bWxcbiAgICAgICAgdGhpcy5jb25kaXRpb25zU3RvcmUgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgICAgIHRoaXMuaW5pdEZpZWxkQ29uZGl0aW9ucygpO1xuICAgIH1cblxuICAgIGluaXRGaWVsZENvbmRpdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuJGZvcm0ucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZmllbGQtY29uZGl0aW9uc10nKS5mb3JFYWNoKCgkZmllbGQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvblNldHRpbmdzID0gdGhpcy5wYXJzZUpzb25Db25kaXRpb25zKCRmaWVsZCk7XG5cbiAgICAgICAgICAgIGlmICghY29uZGl0aW9uU2V0dGluZ3MgfHwgIWNvbmRpdGlvblNldHRpbmdzLmNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgY29uZGl0aW9ucyBhZ2FpbnN0IHRoZSB0YXJnZXQgZmllbGQgb2JqZWN0IGZvciBsYXRlciBhY2Nlc3MvdGVzdGluZ1xuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9ucyA9IFtdO1xuXG4gICAgICAgICAgICBjb25kaXRpb25TZXR0aW5ncy5jb25kaXRpb25zLmZvckVhY2goKGNvbmRpdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZmllbGQocykgd2UncmUgdGFyZ2V0aW5nIHRvIHdhdGNoIGZvciBjaGFuZ2VzLiBOb3RlIHdlIG5lZWQgdG8gaGFuZGxlIG11bHRpcGxlIGZpZWxkcyAoY2hlY2tib3hlcylcbiAgICAgICAgICAgICAgICBsZXQgJHRhcmdldHMgPSB0aGlzLiRmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tuYW1lPVwiJyArIGNvbmRpdGlvbi5maWVsZCArICdcIl0nKTtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBtdWx0aXBsZSBmaWVsZHMsIGxpa2UgY2hlY2tib3hlcy4gVGhpcyBvdmVycmlkZXMgdGhlIGFib3ZlXG4gICAgICAgICAgICAgICAgY29uc3QgJG11bHRpRmllbGRzID0gdGhpcy4kZm9ybS5xdWVyeVNlbGVjdG9yQWxsKCdbbmFtZT1cIicgKyBjb25kaXRpb24uZmllbGQgKyAnW11cIl0nKTtcblxuICAgICAgICAgICAgICAgIGlmICgkbXVsdGlGaWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICR0YXJnZXRzID0gJG11bHRpRmllbGRzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIFJlcGVhdGVyL0dyb3VwcyB0aGF0IGhhdmUgYG5ldzFgIGluIHRoZWlyIG5hbWUgYnV0IGZvciBwYWdlIHJlbG9hZCBmb3Jtc1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgYmxvY2tJZCwgYW5kIHdpbGwgZmFpbCB0byBtYXRjaCB0aGUgY29uZGl0aW9ucyBzZXR0aW5ncy5cbiAgICAgICAgICAgICAgICBpZiAoKCEkdGFyZ2V0cyB8fCAhJHRhcmdldHMubGVuZ3RoKSAmJiBjb25kaXRpb24uZmllbGQuaW5jbHVkZXMoJ1tuZXcxXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0cmlja3kgd2l0aCBSZWdleC4gRmluZCB0aGUgZWxlbWVudCB0aGF0IG1hdGNoZXMgZXZlcnl0aGluZyBleGNlcHQgYFtuZXcxXWAgZm9yIGBbMTIzNF1gLlxuICAgICAgICAgICAgICAgICAgICAvLyBFc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGBbXWAgaW4gdGhlIHN0cmluZywgYW5kIHN3YXAgYFtuZXcxXWAgd2l0aCBgW1xcZCtdYC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVnZXhTdHJpbmcgPSBjb25kaXRpb24uZmllbGQucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKS5yZXBsYWNlKC9uZXcxL2csICdcXFxcZCsnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIGFsbCB0YXJnZXRzIHZpYSBSZWdleC5cbiAgICAgICAgICAgICAgICAgICAgJHRhcmdldHMgPSB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGxSZWdleChuZXcgUmVnRXhwKHJlZ2V4U3RyaW5nKSwgJ25hbWUnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoISR0YXJnZXRzIHx8ICEkdGFyZ2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjb25kaXRpb25zIHdpdGggdGhlIHRhcmdldCBmaWVsZCBmb3IgbGF0ZXIgYWNjZXNzL3Rlc3RpbmdcbiAgICAgICAgICAgICAgICBjb25kaXRpb24uJHRhcmdldHMgPSAkdGFyZ2V0cztcbiAgICAgICAgICAgICAgICBjb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcblxuICAgICAgICAgICAgICAgICR0YXJnZXRzLmZvckVhY2goKCR0YXJnZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByaWdodCBldmVudCBmb3IgdGhlIGZpZWxkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50VHlwZSA9IHRoaXMuZ2V0RXZlbnRUeXBlKCR0YXJnZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdhdGNoIGZvciBjaGFuZ2VzIG9uIHRoZSB0YXJnZXQgZmllbGQuIFdoZW4gb25lIG9jY3VycywgZmlyZSBvZmYgYSBjdXN0b20gZXZlbnQgb24gdGhlIHNvdXJjZSBmaWVsZFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGRvIHRoaXMgYmVjYXVzZSB0YXJnZXQgZmllbGRzIGNhbiBiZSB0YXJnZXR0ZWQgYnkgbXVsdGlwbGUgY29uZGl0aW9ucywgYW5kIHNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAvLyBmaWVsZHMgY2FuIGhhdmUgbXVsdGlwbGUgY29uZGl0aW9ucyAtIHdlIG5lZWQgdG8gY2hlY2sgdGhlbSBhbGwgZm9yIGFsbC9hbnkgbG9naWMuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybS5hZGRFdmVudExpc3RlbmVyKCR0YXJnZXQsIGV2ZW50S2V5KGV2ZW50VHlwZSksICgpID0+ICRmaWVsZC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnb25Gb3JtaWVFdmFsdWF0ZUNvbmRpdGlvbnMnLCB7IGJ1YmJsZXM6IHRydWUgfSkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIFNhdmUgb3VyIGNvbmRpdGlvbiBzZXR0aW5ncyBhbmQgdGFyZ2V0cyBhZ2FpbnN0IHRoZSBvcmlnaW4gZmllbGRzLiBXZSdsbCB1c2UgdGhpcyB0byBldmFsdWF0ZSBjb25kaXRpb25zXG4gICAgICAgICAgICB0aGlzLmNvbmRpdGlvbnNTdG9yZS5zZXQoJGZpZWxkLCB7XG4gICAgICAgICAgICAgICAgc2hvd1J1bGU6IGNvbmRpdGlvblNldHRpbmdzLnNob3dSdWxlLFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvblJ1bGU6IGNvbmRpdGlvblNldHRpbmdzLmNvbmRpdGlvblJ1bGUsXG4gICAgICAgICAgICAgICAgaXNOZXN0ZWQ6IGNvbmRpdGlvblNldHRpbmdzLmlzTmVzdGVkIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbnMsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQWRkIGEgY3VzdG9tIGV2ZW50IGxpc3RlbmVyIHRvIGZpcmUgd2hlbiB0aGUgZmllbGQgZXZlbnQgbGlzdGVuZXIgZmlyZXNcbiAgICAgICAgICAgIHRoaXMuZm9ybS5hZGRFdmVudExpc3RlbmVyKCRmaWVsZCwgZXZlbnRLZXkoJ29uRm9ybWllRXZhbHVhdGVDb25kaXRpb25zJyksIHRoaXMuZXZhbHVhdGVDb25kaXRpb25zLmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAvLyBBbHNvIC0gdHJpZ2dlciB0aGUgZXZlbnQgcmlnaHQgbm93IHRvIGV2YWx1YXRlIGltbWVkaWF0ZWx5LiBOYW1lbHkgaWYgd2UgbmVlZCB0byBoaWRlXG4gICAgICAgICAgICAvLyBmaWVsZCB0aGF0IGFyZSBzZXQgdG8gc2hvdyBpZiBjb25kaXRpb25zIGFyZSBtZXQuIFBhc3MgaW4gYSBwYXJhbSB0byBsZXQgZmllbGRzIGtub3cgaWYgdGhpcyBpcyBcImluaXRcIi5cbiAgICAgICAgICAgICRmaWVsZC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnb25Gb3JtaWVFdmFsdWF0ZUNvbmRpdGlvbnMnLCB7IGJ1YmJsZXM6IHRydWUsIGRldGFpbDogeyBpbml0OiB0cnVlIH0gfSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGZvcm0gaGFzaCwgc28gd2UgZG9uJ3QgZ2V0IGNoYW5nZSB3YXJuaW5nc1xuICAgICAgICBpZiAodGhpcy5mb3JtLmZvcm1UaGVtZSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtLmZvcm1UaGVtZS51cGRhdGVGb3JtSGFzaCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXZhbHVhdGVDb25kaXRpb25zKGUpIHtcbiAgICAgICAgY29uc3QgJGZpZWxkID0gZS50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGlzSW5pdCA9IGUuZGV0YWlsID8gZS5kZXRhaWwuaW5pdCA6IGZhbHNlO1xuXG4gICAgICAgIC8vIEdldCB0aGUgcHJlcHBlZCBjb25kaXRpb25zIGZvciB0aGlzIGZpZWxkXG4gICAgICAgIGNvbnN0IGNvbmRpdGlvblNldHRpbmdzID0gdGhpcy5jb25kaXRpb25zU3RvcmUuZ2V0KCRmaWVsZCk7XG5cbiAgICAgICAgaWYgKCFjb25kaXRpb25TZXR0aW5ncykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBzaG93UnVsZSwgY29uZGl0aW9uUnVsZSwgY29uZGl0aW9ucywgaXNOZXN0ZWQgfSA9IGNvbmRpdGlvblNldHRpbmdzO1xuICAgICAgICBjb25zdCByZXN1bHRzID0ge307XG5cbiAgICAgICAgY29uZGl0aW9ucy5mb3JFYWNoKChjb25kaXRpb24sIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29uZGl0aW9uOiBsb2dpYywgdmFsdWUsICR0YXJnZXRzLCBmaWVsZCB9ID0gY29uZGl0aW9uO1xuXG4gICAgICAgICAgICAvLyBXZSdyZSBhbHdheXMgZGVhbGluZyB3aXRoIGEgY29sbGVjdGlvbiBvZiB0YXJnZXRzLCBldmVuIGlmIHRoZSB0YXJnZXQgaXMgYSB0ZXh0IGZpZWxkXG4gICAgICAgICAgICAvLyBUaGUgcmVhc29uIGJlaW5nIGlzIHRoaXMgbm9ybWFsaXNlcyBiZWhhdmlvdXIgZm9yIHNvbWUgZmllbGRzIChjaGVja2JveC9yYWRpbykgdGhhdFxuICAgICAgICAgICAgLy8gaGF2ZSBtdWx0aXBsZSBmaWVsZHMgaW4gYSBncm91cC5cbiAgICAgICAgICAgICR0YXJnZXRzLmZvckVhY2goKCR0YXJnZXQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdE9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gJHRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXRUeXBlID0gJHRhcmdldC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA/ICR0YXJnZXQuZ2V0QXR0cmlidXRlKCd0eXBlJykudG9Mb3dlckNhc2UoKSA6ICcnO1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEga2V5IGZvciB0aGlzIGNvbmRpdGlvbiBydWxlIHRoYXQgd2UnbGwgdXNlIHRvIHN0b3JlIChwb3RlbnRpYWxseSBtdWx0aXBsZSkgcmVzdWx0cyBhZ2FpbnN0LlxuICAgICAgICAgICAgICAgIC8vIEl0J3Mgbm90IHZpc2libHkgbmVlZGVkIGZvciBhbnl0aGluZywgYnV0IHVzaW5nIHRoZSB0YXJnZXQncyBmaWVsZCBuYW1lIGhlbHBzIHdpdGggZGVidWdnaW5nLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdEtleSA9IGZpZWxkICsgJ18nICsgaTtcblxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGFsbCByZXN1bHRzIGFzIGFuIGFycmF5LCBhbmQgd2UnbGwgbm9ybWFsaXNlIGFmdGVyd2FyZHMuIEdyb3VwIHJlc3VsdHMgYnkgdGhlaXIgY29uZGl0aW9uIHJ1bGUuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IHsgZHJvcGRvd25fMDogW2ZhbHNlXSwgcmFkaW9fMTogW3RydWUsIGZhbHNlXSB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRzW3Jlc3VsdEtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tyZXN1bHRLZXldID0gW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHNvbWUgc3BlY2lhbCBvcHRpb25zIGxpa2UgZGF0ZXMgLSB0ZWxsIG91ciBjb25kaXRpb24gdGVzdGVyIGFib3V0IHRoZW1cbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRUeXBlID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVzdE9wdGlvbnMuaXNEYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYWdyZWUgZmllbGRzLCB3aGljaCBhcmUgYSBzaW5nbGUgY2hlY2tib3gsIGNoZWNrZWQvdW5jaGVja2VkXG4gICAgICAgICAgICAgICAgaWYgKCR0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWZ1aS1pbnB1dC10eXBlJykgPT09ICdhZ3JlZScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHRoZSBlbXB0eSwgaGlkZGVuIGNoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFR5cGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSB2YWx1ZSB0byBib29sZWFuIHRvIGNvbXBhcmVcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy50ZXN0Q29uZGl0aW9uKGxvZ2ljLCAodmFsdWUgPT0gJzAnKSA/IGZhbHNlIDogdHJ1ZSwgJHRhcmdldC5jaGVja2VkKTtcblxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW3Jlc3VsdEtleV0ucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXRUeXBlID09PSAnY2hlY2tib3gnIHx8IGlucHV0VHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgKG11bHRpKSBjaGVja2JveGVzIGFuZCByYWRpbywgd2hpY2ggYXJlIGEgYml0IG9mIGEgcGFpblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnRlc3RDb25kaXRpb24obG9naWMsIHZhbHVlLCAkdGFyZ2V0LnZhbHVlKSAmJiAkdGFyZ2V0LmNoZWNrZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tyZXN1bHRLZXldLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09ICdzZWxlY3QnICYmICR0YXJnZXQuaGFzQXR0cmlidXRlKCdtdWx0aXBsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBtdWx0aS1zZWxlY3RzXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LmZyb20oJHRhcmdldC5vcHRpb25zKS5mb3JFYWNoKCgkb3B0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnRlc3RDb25kaXRpb24obG9naWMsIHZhbHVlLCAkb3B0aW9uLnZhbHVlKSAmJiAkb3B0aW9uLnNlbGVjdGVkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW3Jlc3VsdEtleV0ucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnRlc3RDb25kaXRpb24obG9naWMsIHZhbHVlLCAkdGFyZ2V0LnZhbHVlLCB0ZXN0T3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tyZXN1bHRLZXldLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTm9ybWFsaXNlIHRoZSByZXN1bHRzIGJlZm9yZSBnb2luZyBmdXJ0aGVyLCBhcyB0aGlzJ2xsIGJlIGtleWVkIGFzIGFuIG9iamVjdCwgc28gY29udmVydCB0byBhbiBhcnJheVxuICAgICAgICAvLyBhbmQgYmVjYXVzZSB3ZSBjYW4gaGF2ZSBtdWx0aXBsZSBpbnB1dHMsIGVhY2ggd2l0aCB0aGVpciBvd24gdmFsdWUsIHJlZHVjZSB0aGVtIHRvIGEgc2luZ2xlIGJvb2xlYW4uXG4gICAgICAgIC8vIEZvciBleGFtcGxlOiB7IGRyb3Bkb3duXzA6IFtmYWxzZV0sIHJhZGlvXzE6IFt0cnVlLCBmYWxzZV0gfSBjaGFuZ2VzIHRvIFtmYWxzZSwgdHJ1ZV0uXG4gICAgICAgIGNvbnN0IG5vcm1hbGlzZWRSZXN1bHRzID0gW107XG5cbiAgICAgICAgT2JqZWN0LnZhbHVlcyhyZXN1bHRzKS5mb3JFYWNoKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIG5vcm1hbGlzZWRSZXN1bHRzLnB1c2gocmVzdWx0LmluY2x1ZGVzKHRydWUpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGZpbmFsUmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGhvdyB0byBjb21wYXJlIHRoZSByZXN1bHQgKGFueSBvciBhbGwpLlxuICAgICAgICBpZiAobm9ybWFsaXNlZFJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uUnVsZSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgICAgICAvLyBBcmUgX2FsbF8gdGhlIGNvbmRpdGlvbnMgdGhlIHNhbWU/XG4gICAgICAgICAgICAgICAgZmluYWxSZXN1bHQgPSBub3JtYWxpc2VkUmVzdWx0cy5ldmVyeSgodmFsKSA9PiB2YWwgPT09IHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaW5hbFJlc3VsdCA9IG5vcm1hbGlzZWRSZXN1bHRzLmluY2x1ZGVzKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBjb25kaXRpb24gaXMgbmVzdGVkIGluIGEgR3JvdXAvUmVwZWF0ZXIgZmllbGQuIE9ubHkgcHJvY2VlZCBpZiB0aGUgcGFyZW50IGZpZWxkXG4gICAgICAgIC8vIGNvbmRpdGlvbmFsIGV2YWx1YXRpb24gaGFzIHBhc3NlZC5cbiAgICAgICAgbGV0IG92ZXJyaWRlUmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQnV0ICpkbyogc2V0dXAgY29uZGl0aW9ucyBvbiB0aGUgZmlyc3QgcnVuLCB3aGVuIGluaXRpYWxpc2luZyBhbGwgdGhlIGZpZWxkc1xuICAgICAgICBpZiAoaXNOZXN0ZWQgJiYgIWlzSW5pdCkge1xuICAgICAgICAgICAgdmFyICRwYXJlbnRGaWVsZCA9ICRmaWVsZC5jbG9zZXN0KCcuZnVpLXR5cGUtZ3JvdXAsIC5mdWktdHlwZS1yZXBlYXRlcicpO1xuXG4gICAgICAgICAgICBpZiAoJHBhcmVudEZpZWxkKSB7XG4gICAgICAgICAgICAgICAgLy8gSXMgdGhlIHBhcmVudCBmaWVsZCBjb25kaXRpb25hbGx5IGhpZGRlbj8gRm9yY2UgdGhlIGV2YWx1YXRpb24gdG8gYmUgdHJ1ZSAodGhpcyBmaWVsZCBpc1xuICAgICAgICAgICAgICAgIC8vIGlzIGNvbmRpdGlvbmFsbHUgaGlkZGVuKSwgdG8gcHJldmVudCBpbm5lciBmaWVsZCBjb25kaXRpb25zIGhhdmluZyBhIGhpZ2hlciBwcmlvcml0eSB0aGFuIHRoZVxuICAgICAgICAgICAgICAgIC8vIHBhcmVudCBHcm91cC9SZXBlYXRlciBmaWVsZHMuXG4gICAgICAgICAgICAgICAgaWYgKCRwYXJlbnRGaWVsZC5jb25kaXRpb25hbGx5SGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaG93IG9yIGhpZGU/IEFsc28gdG9nZ2xlIHRoZSBkaXNhYmxlZCBzdGF0ZSB0byBzb3J0IG91dCBhbnkgaGlkZGVuIHJlcXVpcmVkIGZpZWxkc1xuICAgICAgICBpZiAob3ZlcnJpZGVSZXN1bHQgfHwgKGZpbmFsUmVzdWx0ICYmIHNob3dSdWxlICE9PSAnc2hvdycpIHx8ICghZmluYWxSZXN1bHQgJiYgc2hvd1J1bGUgPT09ICdzaG93JykpIHtcbiAgICAgICAgICAgICRmaWVsZC5jb25kaXRpb25hbGx5SGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICRmaWVsZC5zZXRBdHRyaWJ1dGUoJ2RhdGEtY29uZGl0aW9uYWxseS1oaWRkZW4nLCB0cnVlKTtcblxuICAgICAgICAgICAgJGZpZWxkLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LCB0ZXh0YXJlYSwgc2VsZWN0JykuZm9yRWFjaCgoJGlucHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgJGlucHV0LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGZpZWxkLmNvbmRpdGlvbmFsbHlIaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICRmaWVsZC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtY29uZGl0aW9uYWxseS1oaWRkZW4nKTtcblxuICAgICAgICAgICAgJGZpZWxkLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LCB0ZXh0YXJlYSwgc2VsZWN0JykuZm9yRWFjaCgoJGlucHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgJGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyZSBhbiBldmVudCB0byBub3RpZnkgdGhhdCB0aGUgZmllbGQncyBjb25kaXRpb25zIGhhdmUgYmVlbiBldmFsdWF0ZWRcbiAgICAgICAgJGZpZWxkLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdvbkFmdGVyRm9ybWllRXZhbHVhdGVDb25kaXRpb25zJywgeyBidWJibGVzOiB0cnVlLCBkZXRhaWw6IHsgaW5pdDogaXNJbml0IH0gfSkpO1xuICAgIH1cblxuICAgIHBhcnNlSnNvbkNvbmRpdGlvbnMoJGZpZWxkKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSAkZmllbGQuZ2V0QXR0cmlidXRlKCdkYXRhLWZpZWxkLWNvbmRpdGlvbnMnKTtcblxuICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmFibGUgdG8gcGFyc2UgSlNPTiBjb25kaXRpb25zOiAnICsgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0RXZlbnRUeXBlKCRmaWVsZCkge1xuICAgICAgICBjb25zdCB0YWdOYW1lID0gJGZpZWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgaW5wdXRUeXBlID0gJGZpZWxkLmdldEF0dHJpYnV0ZSgndHlwZScpID8gJGZpZWxkLmdldEF0dHJpYnV0ZSgndHlwZScpLnRvTG93ZXJDYXNlKCkgOiAnJztcblxuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ3NlbGVjdCcgfHwgaW5wdXRUeXBlID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgIHJldHVybiAnY2hhbmdlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnB1dFR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lucHV0JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnB1dFR5cGUgPT09ICdjaGVja2JveCcgfHwgaW5wdXRUeXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NsaWNrJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAna2V5dXAnO1xuICAgIH1cblxuICAgIHRlc3RDb25kaXRpb24obG9naWMsIHZhbHVlLCBmaWVsZFZhbHVlLCB0ZXN0T3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgICAvLyBBcmUgd2UgZGVhbGluZyB3aXRoIGRhdGVzPyBUaGF0J3MgYSB3aG9sZSBvdGhlciBtZXNzLi4uXG4gICAgICAgIGlmICh0ZXN0T3B0aW9ucy5pc0RhdGUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBuZXcgRGF0ZShmaWVsZFZhbHVlKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9naWMgPT09ICc9Jykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUgPT09IGZpZWxkVmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAobG9naWMgPT09ICchPScpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlICE9PSBmaWVsZFZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKGxvZ2ljID09PSAnPicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlRmxvYXQoZmllbGRWYWx1ZSwgMTApID4gcGFyc2VGbG9hdCh2YWx1ZSwgMTApO1xuICAgICAgICB9IGVsc2UgaWYgKGxvZ2ljID09PSAnPCcpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlRmxvYXQoZmllbGRWYWx1ZSwgMTApIDwgcGFyc2VGbG9hdCh2YWx1ZSwgMTApO1xuICAgICAgICB9IGVsc2UgaWYgKGxvZ2ljID09PSAnY29udGFpbnMnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmaWVsZFZhbHVlLmluY2x1ZGVzKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2dpYyA9PT0gJ3N0YXJ0c1dpdGgnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmaWVsZFZhbHVlLnN0YXJ0c1dpdGgodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGxvZ2ljID09PSAnZW5kc1dpdGgnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmaWVsZFZhbHVlLmVuZHNXaXRoKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcXVlcnlTZWxlY3RvckFsbFJlZ2V4KHJlZ2V4LCBhdHRyaWJ1dGVUb1NlYXJjaCkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBlbGVtZW50IG9mIHRoaXMuJGZvcm0ucXVlcnlTZWxlY3RvckFsbChgWyR7YXR0cmlidXRlVG9TZWFyY2h9XWApKSB7XG4gICAgICAgICAgICBpZiAocmVnZXgudGVzdChlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVUb1NlYXJjaCkpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbn1cblxud2luZG93LkZvcm1pZUNvbmRpdGlvbnMgPSBGb3JtaWVDb25kaXRpb25zO1xuIl0sIm5hbWVzIjpbImV2ZW50S2V5IiwiRm9ybWllQ29uZGl0aW9ucyIsInNldHRpbmdzIiwiJGZvcm0iLCJmb3JtIiwiY29uZGl0aW9uc1N0b3JlIiwiV2Vha01hcCIsImluaXRGaWVsZENvbmRpdGlvbnMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsIiRmaWVsZCIsImNvbmRpdGlvblNldHRpbmdzIiwicGFyc2VKc29uQ29uZGl0aW9ucyIsImNvbmRpdGlvbnMiLCJsZW5ndGgiLCJjb25kaXRpb24iLCIkdGFyZ2V0cyIsImZpZWxkIiwiJG11bHRpRmllbGRzIiwiaW5jbHVkZXMiLCJyZWdleFN0cmluZyIsInJlcGxhY2UiLCJxdWVyeVNlbGVjdG9yQWxsUmVnZXgiLCJSZWdFeHAiLCJwdXNoIiwiJHRhcmdldCIsImV2ZW50VHlwZSIsImdldEV2ZW50VHlwZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJidWJibGVzIiwic2V0Iiwic2hvd1J1bGUiLCJjb25kaXRpb25SdWxlIiwiaXNOZXN0ZWQiLCJldmFsdWF0ZUNvbmRpdGlvbnMiLCJiaW5kIiwiZGV0YWlsIiwiaW5pdCIsImZvcm1UaGVtZSIsInVwZGF0ZUZvcm1IYXNoIiwiZSIsInRhcmdldCIsImlzSW5pdCIsImdldCIsInJlc3VsdHMiLCJpIiwibG9naWMiLCJ2YWx1ZSIsInJlc3VsdCIsInRlc3RPcHRpb25zIiwidGFnTmFtZSIsInRvTG93ZXJDYXNlIiwiaW5wdXRUeXBlIiwiZ2V0QXR0cmlidXRlIiwicmVzdWx0S2V5IiwiaXNEYXRlIiwidGVzdENvbmRpdGlvbiIsImNoZWNrZWQiLCJoYXNBdHRyaWJ1dGUiLCJBcnJheSIsImZyb20iLCJvcHRpb25zIiwiJG9wdGlvbiIsInNlbGVjdGVkIiwibm9ybWFsaXNlZFJlc3VsdHMiLCJPYmplY3QiLCJ2YWx1ZXMiLCJmaW5hbFJlc3VsdCIsImV2ZXJ5IiwidmFsIiwib3ZlcnJpZGVSZXN1bHQiLCIkcGFyZW50RmllbGQiLCJjbG9zZXN0IiwiY29uZGl0aW9uYWxseUhpZGRlbiIsInNldEF0dHJpYnV0ZSIsIiRpbnB1dCIsInJlbW92ZUF0dHJpYnV0ZSIsImpzb24iLCJKU09OIiwicGFyc2UiLCJjb25zb2xlIiwiZXJyb3IiLCJmaWVsZFZhbHVlIiwiRGF0ZSIsInZhbHVlT2YiLCJwYXJzZUZsb2F0Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwicmVnZXgiLCJhdHRyaWJ1dGVUb1NlYXJjaCIsIm91dHB1dCIsImVsZW1lbnQiLCJ0ZXN0Iiwid2luZG93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/fields/conditions.js\n");

/***/ }),

/***/ "./src/js/utils/utils.js":
/*!*******************************!*\
  !*** ./src/js/utils/utils.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"eventKey\": () => (/* binding */ eventKey),\n/* harmony export */   \"isEmpty\": () => (/* binding */ isEmpty),\n/* harmony export */   \"toBoolean\": () => (/* binding */ toBoolean)\n/* harmony export */ });\nvar isEmpty = function isEmpty(obj) {\n  return obj && Object.keys(obj).length === 0 && obj.constructor === Object;\n};\nvar toBoolean = function toBoolean(val) {\n  return !/^(?:f(?:alse)?|no?|0+)$/i.test(val) && !!val;\n};\nvar eventKey = function eventKey(eventName) {\n  return eventName + '.' + Math.random();\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvdXRpbHMvdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQU8sSUFBTUEsT0FBTyxHQUFHLFNBQVZBLE9BQVUsQ0FBU0MsR0FBVCxFQUFjO0VBQ2pDLE9BQU9BLEdBQUcsSUFBSUMsTUFBTSxDQUFDQyxJQUFQLENBQVlGLEdBQVosRUFBaUJHLE1BQWpCLEtBQTRCLENBQW5DLElBQXdDSCxHQUFHLENBQUNJLFdBQUosS0FBb0JILE1BQW5FO0FBQ0gsQ0FGTTtBQUlBLElBQU1JLFNBQVMsR0FBRyxTQUFaQSxTQUFZLENBQVNDLEdBQVQsRUFBYztFQUNuQyxPQUFPLENBQUMsMkJBQTJCQyxJQUEzQixDQUFnQ0QsR0FBaEMsQ0FBRCxJQUF5QyxDQUFDLENBQUNBLEdBQWxEO0FBQ0gsQ0FGTTtBQUlBLElBQU1FLFFBQVEsR0FBRyxTQUFYQSxRQUFXLENBQVNDLFNBQVQsRUFBb0I7RUFDeEMsT0FBT0EsU0FBUyxHQUFHLEdBQVosR0FBa0JDLElBQUksQ0FBQ0MsTUFBTCxFQUF6QjtBQUNILENBRk0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbHMvdXRpbHMuanM/ZDllZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDAgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59O1xuXG5leHBvcnQgY29uc3QgdG9Cb29sZWFuID0gZnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuICEvXig/OmYoPzphbHNlKT98bm8/fDArKSQvaS50ZXN0KHZhbCkgJiYgISF2YWw7XG59O1xuXG5leHBvcnQgY29uc3QgZXZlbnRLZXkgPSBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICByZXR1cm4gZXZlbnROYW1lICsgJy4nICsgTWF0aC5yYW5kb20oKTtcbn07XG5cbiJdLCJuYW1lcyI6WyJpc0VtcHR5Iiwib2JqIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImNvbnN0cnVjdG9yIiwidG9Cb29sZWFuIiwidmFsIiwidGVzdCIsImV2ZW50S2V5IiwiZXZlbnROYW1lIiwiTWF0aCIsInJhbmRvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/utils/utils.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/fields/conditions.js");
/******/ 	
/******/ })()
;