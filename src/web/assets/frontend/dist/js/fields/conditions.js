/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/fields/conditions.js":
/*!*************************************!*\
  !*** ./src/js/fields/conditions.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormieConditions\": () => (/* binding */ FormieConditions)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ \"./src/js/utils/utils.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\nvar FormieConditions = /*#__PURE__*/function () {\n  function FormieConditions() {\n    var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, FormieConditions);\n\n    this.$form = settings.$form;\n    this.form = this.$form.form; // Best-practice for storing data keyed by DOM nodes\n    // https://fitzgeraldnick.com/2014/01/13/hiding-implementation-details-with-e6-weakmaps.html\n\n    this.conditionsStore = new WeakMap();\n    this.initFieldConditions();\n  }\n\n  _createClass(FormieConditions, [{\n    key: \"initFieldConditions\",\n    value: function initFieldConditions() {\n      var _this = this;\n\n      this.$form.querySelectorAll('[data-field-conditions]').forEach(function ($field) {\n        var conditionSettings = _this.parseJsonConditions($field);\n\n        if (!conditionSettings || !conditionSettings.conditions.length) {\n          return;\n        } // Store the conditions against the target field object for later access/testing\n\n\n        var conditions = [];\n        conditionSettings.conditions.forEach(function (condition) {\n          // Get the field(s) we're targeting to watch for changes. Note we need to handle multiple fields (checkboxes)\n          var $targets = _this.$form.querySelectorAll(\"[name=\\\"\".concat(condition.field, \"\\\"]\")); // Check if we're dealing with multiple fields, like checkboxes. This overrides the above\n\n\n          var $multiFields = _this.$form.querySelectorAll(\"[name=\\\"\".concat(condition.field, \"[]\\\"]\"));\n\n          if ($multiFields.length) {\n            $targets = $multiFields;\n          } // Special handling for Repeater/Groups that have `new1` in their name but for page reload forms\n          // this will be replaced by the blockId, and will fail to match the conditions settings.\n\n\n          if ((!$targets || !$targets.length) && condition.field.includes('[new1]')) {\n            // Get tricky with Regex. Find the element that matches everything except `[new1]` for `[1234]`.\n            // Escape special characters `[]` in the string, and swap `[new1]` with `[\\d+]`.\n            var regexString = condition.field.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&').replace(/new1/g, '\\\\d+'); // Find all targets via Regex.\n\n            $targets = _this.querySelectorAllRegex(new RegExp(regexString), 'name');\n          }\n\n          if (!$targets || !$targets.length) {\n            return;\n          } // Store the conditions with the target field for later access/testing\n\n\n          condition.$targets = $targets;\n          conditions.push(condition);\n          $targets.forEach(function ($target) {\n            // Get the right event for the field\n            var eventType = _this.getEventType($target); // Watch for changes on the target field. When one occurs, fire off a custom event on the source field\n            // We need to do this because target fields can be targetted by multiple conditions, and source\n            // fields can have multiple conditions - we need to check them all for all/any logic.\n\n\n            _this.form.addEventListener($target, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.eventKey)(eventType), function () {\n              return $field.dispatchEvent(new CustomEvent('onFormieEvaluateConditions', {\n                bubbles: true\n              }));\n            });\n          });\n        }); // Save our condition settings and targets against the origin fields. We'll use this to evaluate conditions\n\n        _this.conditionsStore.set($field, {\n          showRule: conditionSettings.showRule,\n          conditionRule: conditionSettings.conditionRule,\n          isNested: conditionSettings.isNested || false,\n          conditions: conditions\n        }); // Add a custom event listener to fire when the field event listener fires\n\n\n        _this.form.addEventListener($field, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.eventKey)('onFormieEvaluateConditions'), _this.evaluateConditions.bind(_this)); // Also - trigger the event right now to evaluate immediately. Namely if we need to hide\n        // field that are set to show if conditions are met. Pass in a param to let fields know if this is \"init\".\n\n\n        $field.dispatchEvent(new CustomEvent('onFormieEvaluateConditions', {\n          bubbles: true,\n          detail: {\n            init: true\n          }\n        }));\n      }); // Update the form hash, so we don't get change warnings\n\n      if (this.form.formTheme) {\n        this.form.formTheme.updateFormHash();\n      }\n    }\n  }, {\n    key: \"evaluateConditions\",\n    value: function evaluateConditions(e) {\n      var _this2 = this;\n\n      var $field = e.target;\n      var isInit = e.detail ? e.detail.init : false; // Get the prepped conditions for this field\n\n      var conditionSettings = this.conditionsStore.get($field);\n\n      if (!conditionSettings) {\n        return;\n      }\n\n      var showRule = conditionSettings.showRule,\n          conditionRule = conditionSettings.conditionRule,\n          conditions = conditionSettings.conditions,\n          isNested = conditionSettings.isNested;\n      var results = {};\n      conditions.forEach(function (condition, i) {\n        var logic = condition.condition,\n            value = condition.value,\n            $targets = condition.$targets,\n            field = condition.field; // We're always dealing with a collection of targets, even if the target is a text field\n        // The reason being is this normalises behaviour for some fields (checkbox/radio) that\n        // have multiple fields in a group.\n\n        $targets.forEach(function ($target) {\n          var result = false;\n          var testOptions = {};\n          var tagName = $target.tagName.toLowerCase();\n          var inputType = $target.getAttribute('type') ? $target.getAttribute('type').toLowerCase() : ''; // Create a key for this condition rule that we'll use to store (potentially multiple) results against.\n          // It's not visibly needed for anything, but using the target's field name helps with debugging.\n\n          var resultKey = \"\".concat(field, \"_\").concat(i); // Store all results as an array, and we'll normalise afterwards. Group results by their condition rule.\n          // For example: { dropdown_0: [false], radio_1: [true, false] }\n\n          if (!results[resultKey]) {\n            results[resultKey] = [];\n          } // Handle some special options like dates - tell our condition tester about them\n\n\n          if (inputType === 'date') {\n            testOptions.isDate = true;\n          } // Handle agree fields, which are a single checkbox, checked/unchecked\n\n\n          if ($target.getAttribute('data-fui-input-type') === 'agree') {\n            // Ignore the empty, hidden checkbox\n            if (inputType === 'hidden') {\n              return;\n            } // Convert the value to boolean to compare\n\n\n            result = _this2.testCondition(logic, value == '0' ? false : true, $target.checked);\n            results[resultKey].push(result);\n          } else if (inputType === 'checkbox' || inputType === 'radio') {\n            // Handle (multi) checkboxes and radio, which are a bit of a pain\n            result = _this2.testCondition(logic, value, $target.value) && $target.checked;\n            results[resultKey].push(result);\n          } else if (tagName === 'select' && $target.hasAttribute('multiple')) {\n            // Handle multi-selects\n            Array.from($target.options).forEach(function ($option) {\n              result = _this2.testCondition(logic, value, $option.value) && $option.selected;\n              results[resultKey].push(result);\n            });\n          } else {\n            result = _this2.testCondition(logic, value, $target.value, testOptions);\n            results[resultKey].push(result);\n          }\n        });\n      }); // Normalise the results before going further, as this'll be keyed as an object, so convert to an array\n      // and because we can have multiple inputs, each with their own value, reduce them to a single boolean.\n      // For example: { dropdown_0: [false], radio_1: [true, false] } changes to [false, true].\n\n      var normalisedResults = [];\n      Object.values(results).forEach(function (result) {\n        normalisedResults.push(result.includes(true));\n      });\n      var finalResult = false; // Check to see how to compare the result (any or all).\n\n      if (normalisedResults.length) {\n        if (conditionRule === 'all') {\n          // Are _all_ the conditions the same?\n          finalResult = normalisedResults.every(function (val) {\n            return val === true;\n          });\n        } else {\n          finalResult = normalisedResults.includes(true);\n        }\n      } // Check if this condition is nested in a Group/Repeater field. Only proceed if the parent field\n      // conditional evaluation has passed.\n\n\n      var overrideResult = false; // But *do* setup conditions on the first run, when initialising all the fields\n\n      if (isNested && !isInit) {\n        var $parentField = $field.closest('[data-field-type=\"group\"], [data-field-type=\"repeater\"]');\n\n        if ($parentField) {\n          // Is the parent field conditionally hidden? Force the evaluation to be true (this field is\n          // is conditionallu hidden), to prevent inner field conditions having a higher priority than the\n          // parent Group/Repeater fields.\n          if ($parentField.conditionallyHidden) {\n            overrideResult = true;\n          }\n        }\n      } // Show or hide? Also toggle the disabled state to sort out any hidden required fields\n\n\n      if (overrideResult || finalResult && showRule !== 'show' || !finalResult && showRule === 'show') {\n        $field.conditionallyHidden = true;\n        $field.setAttribute('data-conditionally-hidden', true);\n        $field.querySelectorAll('input, textarea, select').forEach(function ($input) {\n          $input.setAttribute('disabled', true);\n        });\n      } else {\n        $field.conditionallyHidden = false;\n        $field.removeAttribute('data-conditionally-hidden');\n        $field.querySelectorAll('input, textarea, select').forEach(function ($input) {\n          $input.removeAttribute('disabled');\n        });\n      } // Fire an event to notify that the field's conditions have been evaluated\n\n\n      $field.dispatchEvent(new CustomEvent('onAfterFormieEvaluateConditions', {\n        bubbles: true,\n        detail: {\n          init: isInit\n        }\n      }));\n    }\n  }, {\n    key: \"parseJsonConditions\",\n    value: function parseJsonConditions($field) {\n      var json = $field.getAttribute('data-field-conditions');\n\n      if (json) {\n        try {\n          return JSON.parse(json);\n        } catch (e) {\n          console.error(\"Unable to parse JSON conditions: \".concat(e));\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getEventType\",\n    value: function getEventType($field) {\n      var tagName = $field.tagName.toLowerCase();\n      var inputType = $field.getAttribute('type') ? $field.getAttribute('type').toLowerCase() : '';\n\n      if (tagName === 'select' || inputType === 'date') {\n        return 'change';\n      }\n\n      if (inputType === 'number') {\n        return 'input';\n      }\n\n      if (inputType === 'checkbox' || inputType === 'radio') {\n        return 'click';\n      }\n\n      return 'keyup';\n    }\n  }, {\n    key: \"testCondition\",\n    value: function testCondition(logic, value, fieldValue) {\n      var testOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var result = false; // Are we dealing with dates? That's a whole other mess...\n\n      if (testOptions.isDate) {\n        value = new Date(value).valueOf();\n        fieldValue = new Date(fieldValue).valueOf();\n      }\n\n      if (logic === '=') {\n        result = value === fieldValue;\n      } else if (logic === '!=') {\n        result = value !== fieldValue;\n      } else if (logic === '>') {\n        result = parseFloat(fieldValue, 10) > parseFloat(value, 10);\n      } else if (logic === '<') {\n        result = parseFloat(fieldValue, 10) < parseFloat(value, 10);\n      } else if (logic === 'contains') {\n        result = fieldValue.includes(value);\n      } else if (logic === 'startsWith') {\n        result = fieldValue.startsWith(value);\n      } else if (logic === 'endsWith') {\n        result = fieldValue.endsWith(value);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"querySelectorAllRegex\",\n    value: function querySelectorAllRegex(regex, attributeToSearch) {\n      var output = [];\n\n      var _iterator = _createForOfIteratorHelper(this.$form.querySelectorAll(\"[\".concat(attributeToSearch, \"]\"))),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var element = _step.value;\n\n          if (regex.test(element.getAttribute(attributeToSearch))) {\n            output.push(element);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return output;\n    }\n  }]);\n\n  return FormieConditions;\n}();\nwindow.FormieConditions = FormieConditions;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEVBQTZCQyxpQkFBN0IsRUFBZ0Q7TUFDNUMsSUFBTUMsTUFBTSxHQUFHLEVBQWY7O01BRDRDLDJDQUd0QixLQUFLekYsS0FBTCxDQUFXSyxnQkFBWCxZQUFnQ21GLGlCQUFoQyxPQUhzQjtNQUFBOztNQUFBO1FBRzVDLG9EQUE2RTtVQUFBLElBQWxFRSxPQUFrRTs7VUFDekUsSUFBSUgsS0FBSyxDQUFDSSxJQUFOLENBQVdELE9BQU8sQ0FBQ3RDLFlBQVIsQ0FBcUJvQyxpQkFBckIsQ0FBWCxDQUFKLEVBQXlEO1lBQ3JEQyxNQUFNLENBQUNwRSxJQUFQLENBQVlxRSxPQUFaO1VBQ0g7UUFDSjtNQVAyQztRQUFBO01BQUE7UUFBQTtNQUFBOztNQVM1QyxPQUFPRCxNQUFQO0lBQ0g7RUFyU0w7O0VBQUE7QUFBQTtBQXdTQUcsTUFBTSxDQUFDOUYsZ0JBQVAsR0FBMEJBLGdCQUExQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9maWVsZHMvY29uZGl0aW9ucy5qcz8yOWU0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV2ZW50S2V5IH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuXG5leHBvcnQgY2xhc3MgRm9ybWllQ29uZGl0aW9ucyB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSkge1xuICAgICAgICB0aGlzLiRmb3JtID0gc2V0dGluZ3MuJGZvcm07XG4gICAgICAgIHRoaXMuZm9ybSA9IHRoaXMuJGZvcm0uZm9ybTtcblxuICAgICAgICAvLyBCZXN0LXByYWN0aWNlIGZvciBzdG9yaW5nIGRhdGEga2V5ZWQgYnkgRE9NIG5vZGVzXG4gICAgICAgIC8vIGh0dHBzOi8vZml0emdlcmFsZG5pY2suY29tLzIwMTQvMDEvMTMvaGlkaW5nLWltcGxlbWVudGF0aW9uLWRldGFpbHMtd2l0aC1lNi13ZWFrbWFwcy5odG1sXG4gICAgICAgIHRoaXMuY29uZGl0aW9uc1N0b3JlID0gbmV3IFdlYWtNYXAoKTtcblxuICAgICAgICB0aGlzLmluaXRGaWVsZENvbmRpdGlvbnMoKTtcbiAgICB9XG5cbiAgICBpbml0RmllbGRDb25kaXRpb25zKCkge1xuICAgICAgICB0aGlzLiRmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWZpZWxkLWNvbmRpdGlvbnNdJykuZm9yRWFjaCgoJGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb25kaXRpb25TZXR0aW5ncyA9IHRoaXMucGFyc2VKc29uQ29uZGl0aW9ucygkZmllbGQpO1xuXG4gICAgICAgICAgICBpZiAoIWNvbmRpdGlvblNldHRpbmdzIHx8ICFjb25kaXRpb25TZXR0aW5ncy5jb25kaXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGNvbmRpdGlvbnMgYWdhaW5zdCB0aGUgdGFyZ2V0IGZpZWxkIG9iamVjdCBmb3IgbGF0ZXIgYWNjZXNzL3Rlc3RpbmdcbiAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbnMgPSBbXTtcblxuICAgICAgICAgICAgY29uZGl0aW9uU2V0dGluZ3MuY29uZGl0aW9ucy5mb3JFYWNoKChjb25kaXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGZpZWxkKHMpIHdlJ3JlIHRhcmdldGluZyB0byB3YXRjaCBmb3IgY2hhbmdlcy4gTm90ZSB3ZSBuZWVkIHRvIGhhbmRsZSBtdWx0aXBsZSBmaWVsZHMgKGNoZWNrYm94ZXMpXG4gICAgICAgICAgICAgICAgbGV0ICR0YXJnZXRzID0gdGhpcy4kZm9ybS5xdWVyeVNlbGVjdG9yQWxsKGBbbmFtZT1cIiR7Y29uZGl0aW9uLmZpZWxkfVwiXWApO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIG11bHRpcGxlIGZpZWxkcywgbGlrZSBjaGVja2JveGVzLiBUaGlzIG92ZXJyaWRlcyB0aGUgYWJvdmVcbiAgICAgICAgICAgICAgICBjb25zdCAkbXVsdGlGaWVsZHMgPSB0aGlzLiRmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoYFtuYW1lPVwiJHtjb25kaXRpb24uZmllbGR9W11cIl1gKTtcblxuICAgICAgICAgICAgICAgIGlmICgkbXVsdGlGaWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICR0YXJnZXRzID0gJG11bHRpRmllbGRzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIFJlcGVhdGVyL0dyb3VwcyB0aGF0IGhhdmUgYG5ldzFgIGluIHRoZWlyIG5hbWUgYnV0IGZvciBwYWdlIHJlbG9hZCBmb3Jtc1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgYmxvY2tJZCwgYW5kIHdpbGwgZmFpbCB0byBtYXRjaCB0aGUgY29uZGl0aW9ucyBzZXR0aW5ncy5cbiAgICAgICAgICAgICAgICBpZiAoKCEkdGFyZ2V0cyB8fCAhJHRhcmdldHMubGVuZ3RoKSAmJiBjb25kaXRpb24uZmllbGQuaW5jbHVkZXMoJ1tuZXcxXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0cmlja3kgd2l0aCBSZWdleC4gRmluZCB0aGUgZWxlbWVudCB0aGF0IG1hdGNoZXMgZXZlcnl0aGluZyBleGNlcHQgYFtuZXcxXWAgZm9yIGBbMTIzNF1gLlxuICAgICAgICAgICAgICAgICAgICAvLyBFc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGBbXWAgaW4gdGhlIHN0cmluZywgYW5kIHN3YXAgYFtuZXcxXWAgd2l0aCBgW1xcZCtdYC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVnZXhTdHJpbmcgPSBjb25kaXRpb24uZmllbGQucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKS5yZXBsYWNlKC9uZXcxL2csICdcXFxcZCsnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIGFsbCB0YXJnZXRzIHZpYSBSZWdleC5cbiAgICAgICAgICAgICAgICAgICAgJHRhcmdldHMgPSB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGxSZWdleChuZXcgUmVnRXhwKHJlZ2V4U3RyaW5nKSwgJ25hbWUnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoISR0YXJnZXRzIHx8ICEkdGFyZ2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjb25kaXRpb25zIHdpdGggdGhlIHRhcmdldCBmaWVsZCBmb3IgbGF0ZXIgYWNjZXNzL3Rlc3RpbmdcbiAgICAgICAgICAgICAgICBjb25kaXRpb24uJHRhcmdldHMgPSAkdGFyZ2V0cztcbiAgICAgICAgICAgICAgICBjb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcblxuICAgICAgICAgICAgICAgICR0YXJnZXRzLmZvckVhY2goKCR0YXJnZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByaWdodCBldmVudCBmb3IgdGhlIGZpZWxkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50VHlwZSA9IHRoaXMuZ2V0RXZlbnRUeXBlKCR0YXJnZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdhdGNoIGZvciBjaGFuZ2VzIG9uIHRoZSB0YXJnZXQgZmllbGQuIFdoZW4gb25lIG9jY3VycywgZmlyZSBvZmYgYSBjdXN0b20gZXZlbnQgb24gdGhlIHNvdXJjZSBmaWVsZFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGRvIHRoaXMgYmVjYXVzZSB0YXJnZXQgZmllbGRzIGNhbiBiZSB0YXJnZXR0ZWQgYnkgbXVsdGlwbGUgY29uZGl0aW9ucywgYW5kIHNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAvLyBmaWVsZHMgY2FuIGhhdmUgbXVsdGlwbGUgY29uZGl0aW9ucyAtIHdlIG5lZWQgdG8gY2hlY2sgdGhlbSBhbGwgZm9yIGFsbC9hbnkgbG9naWMuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybS5hZGRFdmVudExpc3RlbmVyKCR0YXJnZXQsIGV2ZW50S2V5KGV2ZW50VHlwZSksICgpID0+IHsgcmV0dXJuICRmaWVsZC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnb25Gb3JtaWVFdmFsdWF0ZUNvbmRpdGlvbnMnLCB7IGJ1YmJsZXM6IHRydWUgfSkpOyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTYXZlIG91ciBjb25kaXRpb24gc2V0dGluZ3MgYW5kIHRhcmdldHMgYWdhaW5zdCB0aGUgb3JpZ2luIGZpZWxkcy4gV2UnbGwgdXNlIHRoaXMgdG8gZXZhbHVhdGUgY29uZGl0aW9uc1xuICAgICAgICAgICAgdGhpcy5jb25kaXRpb25zU3RvcmUuc2V0KCRmaWVsZCwge1xuICAgICAgICAgICAgICAgIHNob3dSdWxlOiBjb25kaXRpb25TZXR0aW5ncy5zaG93UnVsZSxcbiAgICAgICAgICAgICAgICBjb25kaXRpb25SdWxlOiBjb25kaXRpb25TZXR0aW5ncy5jb25kaXRpb25SdWxlLFxuICAgICAgICAgICAgICAgIGlzTmVzdGVkOiBjb25kaXRpb25TZXR0aW5ncy5pc05lc3RlZCB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25kaXRpb25zLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBhIGN1c3RvbSBldmVudCBsaXN0ZW5lciB0byBmaXJlIHdoZW4gdGhlIGZpZWxkIGV2ZW50IGxpc3RlbmVyIGZpcmVzXG4gICAgICAgICAgICB0aGlzLmZvcm0uYWRkRXZlbnRMaXN0ZW5lcigkZmllbGQsIGV2ZW50S2V5KCdvbkZvcm1pZUV2YWx1YXRlQ29uZGl0aW9ucycpLCB0aGlzLmV2YWx1YXRlQ29uZGl0aW9ucy5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgLy8gQWxzbyAtIHRyaWdnZXIgdGhlIGV2ZW50IHJpZ2h0IG5vdyB0byBldmFsdWF0ZSBpbW1lZGlhdGVseS4gTmFtZWx5IGlmIHdlIG5lZWQgdG8gaGlkZVxuICAgICAgICAgICAgLy8gZmllbGQgdGhhdCBhcmUgc2V0IHRvIHNob3cgaWYgY29uZGl0aW9ucyBhcmUgbWV0LiBQYXNzIGluIGEgcGFyYW0gdG8gbGV0IGZpZWxkcyBrbm93IGlmIHRoaXMgaXMgXCJpbml0XCIuXG4gICAgICAgICAgICAkZmllbGQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ29uRm9ybWllRXZhbHVhdGVDb25kaXRpb25zJywgeyBidWJibGVzOiB0cnVlLCBkZXRhaWw6IHsgaW5pdDogdHJ1ZSB9IH0pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBmb3JtIGhhc2gsIHNvIHdlIGRvbid0IGdldCBjaGFuZ2Ugd2FybmluZ3NcbiAgICAgICAgaWYgKHRoaXMuZm9ybS5mb3JtVGhlbWUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybS5mb3JtVGhlbWUudXBkYXRlRm9ybUhhc2goKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV2YWx1YXRlQ29uZGl0aW9ucyhlKSB7XG4gICAgICAgIGNvbnN0ICRmaWVsZCA9IGUudGFyZ2V0O1xuICAgICAgICBjb25zdCBpc0luaXQgPSBlLmRldGFpbCA/IGUuZGV0YWlsLmluaXQgOiBmYWxzZTtcblxuICAgICAgICAvLyBHZXQgdGhlIHByZXBwZWQgY29uZGl0aW9ucyBmb3IgdGhpcyBmaWVsZFxuICAgICAgICBjb25zdCBjb25kaXRpb25TZXR0aW5ncyA9IHRoaXMuY29uZGl0aW9uc1N0b3JlLmdldCgkZmllbGQpO1xuXG4gICAgICAgIGlmICghY29uZGl0aW9uU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHNob3dSdWxlLCBjb25kaXRpb25SdWxlLCBjb25kaXRpb25zLCBpc05lc3RlZCxcbiAgICAgICAgfSA9IGNvbmRpdGlvblNldHRpbmdzO1xuICAgICAgICBjb25zdCByZXN1bHRzID0ge307XG5cbiAgICAgICAgY29uZGl0aW9ucy5mb3JFYWNoKChjb25kaXRpb24sIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IGxvZ2ljLCB2YWx1ZSwgJHRhcmdldHMsIGZpZWxkLFxuICAgICAgICAgICAgfSA9IGNvbmRpdGlvbjtcblxuICAgICAgICAgICAgLy8gV2UncmUgYWx3YXlzIGRlYWxpbmcgd2l0aCBhIGNvbGxlY3Rpb24gb2YgdGFyZ2V0cywgZXZlbiBpZiB0aGUgdGFyZ2V0IGlzIGEgdGV4dCBmaWVsZFxuICAgICAgICAgICAgLy8gVGhlIHJlYXNvbiBiZWluZyBpcyB0aGlzIG5vcm1hbGlzZXMgYmVoYXZpb3VyIGZvciBzb21lIGZpZWxkcyAoY2hlY2tib3gvcmFkaW8pIHRoYXRcbiAgICAgICAgICAgIC8vIGhhdmUgbXVsdGlwbGUgZmllbGRzIGluIGEgZ3JvdXAuXG4gICAgICAgICAgICAkdGFyZ2V0cy5mb3JFYWNoKCgkdGFyZ2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RPcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgY29uc3QgdGFnTmFtZSA9ICR0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0VHlwZSA9ICR0YXJnZXQuZ2V0QXR0cmlidXRlKCd0eXBlJykgPyAkdGFyZ2V0LmdldEF0dHJpYnV0ZSgndHlwZScpLnRvTG93ZXJDYXNlKCkgOiAnJztcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGtleSBmb3IgdGhpcyBjb25kaXRpb24gcnVsZSB0aGF0IHdlJ2xsIHVzZSB0byBzdG9yZSAocG90ZW50aWFsbHkgbXVsdGlwbGUpIHJlc3VsdHMgYWdhaW5zdC5cbiAgICAgICAgICAgICAgICAvLyBJdCdzIG5vdCB2aXNpYmx5IG5lZWRlZCBmb3IgYW55dGhpbmcsIGJ1dCB1c2luZyB0aGUgdGFyZ2V0J3MgZmllbGQgbmFtZSBoZWxwcyB3aXRoIGRlYnVnZ2luZy5cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRLZXkgPSBgJHtmaWVsZH1fJHtpfWA7XG5cbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBhbGwgcmVzdWx0cyBhcyBhbiBhcnJheSwgYW5kIHdlJ2xsIG5vcm1hbGlzZSBhZnRlcndhcmRzLiBHcm91cCByZXN1bHRzIGJ5IHRoZWlyIGNvbmRpdGlvbiBydWxlLlxuICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiB7IGRyb3Bkb3duXzA6IFtmYWxzZV0sIHJhZGlvXzE6IFt0cnVlLCBmYWxzZV0gfVxuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0c1tyZXN1bHRLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbcmVzdWx0S2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBzb21lIHNwZWNpYWwgb3B0aW9ucyBsaWtlIGRhdGVzIC0gdGVsbCBvdXIgY29uZGl0aW9uIHRlc3RlciBhYm91dCB0aGVtXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0VHlwZSA9PT0gJ2RhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RPcHRpb25zLmlzRGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGFncmVlIGZpZWxkcywgd2hpY2ggYXJlIGEgc2luZ2xlIGNoZWNrYm94LCBjaGVja2VkL3VuY2hlY2tlZFxuICAgICAgICAgICAgICAgIGlmICgkdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1mdWktaW5wdXQtdHlwZScpID09PSAnYWdyZWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aGUgZW1wdHksIGhpZGRlbiBjaGVja2JveFxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRUeXBlID09PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgdmFsdWUgdG8gYm9vbGVhbiB0byBjb21wYXJlXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMudGVzdENvbmRpdGlvbihsb2dpYywgKHZhbHVlID09ICcwJykgPyBmYWxzZSA6IHRydWUsICR0YXJnZXQuY2hlY2tlZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tyZXN1bHRLZXldLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0VHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBpbnB1dFR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIChtdWx0aSkgY2hlY2tib3hlcyBhbmQgcmFkaW8sIHdoaWNoIGFyZSBhIGJpdCBvZiBhIHBhaW5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy50ZXN0Q29uZGl0aW9uKGxvZ2ljLCB2YWx1ZSwgJHRhcmdldC52YWx1ZSkgJiYgJHRhcmdldC5jaGVja2VkO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbcmVzdWx0S2V5XS5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSAnc2VsZWN0JyAmJiAkdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgbXVsdGktc2VsZWN0c1xuICAgICAgICAgICAgICAgICAgICBBcnJheS5mcm9tKCR0YXJnZXQub3B0aW9ucykuZm9yRWFjaCgoJG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy50ZXN0Q29uZGl0aW9uKGxvZ2ljLCB2YWx1ZSwgJG9wdGlvbi52YWx1ZSkgJiYgJG9wdGlvbi5zZWxlY3RlZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tyZXN1bHRLZXldLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy50ZXN0Q29uZGl0aW9uKGxvZ2ljLCB2YWx1ZSwgJHRhcmdldC52YWx1ZSwgdGVzdE9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbcmVzdWx0S2V5XS5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE5vcm1hbGlzZSB0aGUgcmVzdWx0cyBiZWZvcmUgZ29pbmcgZnVydGhlciwgYXMgdGhpcydsbCBiZSBrZXllZCBhcyBhbiBvYmplY3QsIHNvIGNvbnZlcnQgdG8gYW4gYXJyYXlcbiAgICAgICAgLy8gYW5kIGJlY2F1c2Ugd2UgY2FuIGhhdmUgbXVsdGlwbGUgaW5wdXRzLCBlYWNoIHdpdGggdGhlaXIgb3duIHZhbHVlLCByZWR1Y2UgdGhlbSB0byBhIHNpbmdsZSBib29sZWFuLlxuICAgICAgICAvLyBGb3IgZXhhbXBsZTogeyBkcm9wZG93bl8wOiBbZmFsc2VdLCByYWRpb18xOiBbdHJ1ZSwgZmFsc2VdIH0gY2hhbmdlcyB0byBbZmFsc2UsIHRydWVdLlxuICAgICAgICBjb25zdCBub3JtYWxpc2VkUmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIE9iamVjdC52YWx1ZXMocmVzdWx0cykuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBub3JtYWxpc2VkUmVzdWx0cy5wdXNoKHJlc3VsdC5pbmNsdWRlcyh0cnVlKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBmaW5hbFJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBob3cgdG8gY29tcGFyZSB0aGUgcmVzdWx0IChhbnkgb3IgYWxsKS5cbiAgICAgICAgaWYgKG5vcm1hbGlzZWRSZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGNvbmRpdGlvblJ1bGUgPT09ICdhbGwnKSB7XG4gICAgICAgICAgICAgICAgLy8gQXJlIF9hbGxfIHRoZSBjb25kaXRpb25zIHRoZSBzYW1lP1xuICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0ID0gbm9ybWFsaXNlZFJlc3VsdHMuZXZlcnkoKHZhbCkgPT4geyByZXR1cm4gdmFsID09PSB0cnVlOyB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmluYWxSZXN1bHQgPSBub3JtYWxpc2VkUmVzdWx0cy5pbmNsdWRlcyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgY29uZGl0aW9uIGlzIG5lc3RlZCBpbiBhIEdyb3VwL1JlcGVhdGVyIGZpZWxkLiBPbmx5IHByb2NlZWQgaWYgdGhlIHBhcmVudCBmaWVsZFxuICAgICAgICAvLyBjb25kaXRpb25hbCBldmFsdWF0aW9uIGhhcyBwYXNzZWQuXG4gICAgICAgIGxldCBvdmVycmlkZVJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEJ1dCAqZG8qIHNldHVwIGNvbmRpdGlvbnMgb24gdGhlIGZpcnN0IHJ1biwgd2hlbiBpbml0aWFsaXNpbmcgYWxsIHRoZSBmaWVsZHNcbiAgICAgICAgaWYgKGlzTmVzdGVkICYmICFpc0luaXQpIHtcbiAgICAgICAgICAgIGNvbnN0ICRwYXJlbnRGaWVsZCA9ICRmaWVsZC5jbG9zZXN0KCdbZGF0YS1maWVsZC10eXBlPVwiZ3JvdXBcIl0sIFtkYXRhLWZpZWxkLXR5cGU9XCJyZXBlYXRlclwiXScpO1xuXG4gICAgICAgICAgICBpZiAoJHBhcmVudEZpZWxkKSB7XG4gICAgICAgICAgICAgICAgLy8gSXMgdGhlIHBhcmVudCBmaWVsZCBjb25kaXRpb25hbGx5IGhpZGRlbj8gRm9yY2UgdGhlIGV2YWx1YXRpb24gdG8gYmUgdHJ1ZSAodGhpcyBmaWVsZCBpc1xuICAgICAgICAgICAgICAgIC8vIGlzIGNvbmRpdGlvbmFsbHUgaGlkZGVuKSwgdG8gcHJldmVudCBpbm5lciBmaWVsZCBjb25kaXRpb25zIGhhdmluZyBhIGhpZ2hlciBwcmlvcml0eSB0aGFuIHRoZVxuICAgICAgICAgICAgICAgIC8vIHBhcmVudCBHcm91cC9SZXBlYXRlciBmaWVsZHMuXG4gICAgICAgICAgICAgICAgaWYgKCRwYXJlbnRGaWVsZC5jb25kaXRpb25hbGx5SGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaG93IG9yIGhpZGU/IEFsc28gdG9nZ2xlIHRoZSBkaXNhYmxlZCBzdGF0ZSB0byBzb3J0IG91dCBhbnkgaGlkZGVuIHJlcXVpcmVkIGZpZWxkc1xuICAgICAgICBpZiAob3ZlcnJpZGVSZXN1bHQgfHwgKGZpbmFsUmVzdWx0ICYmIHNob3dSdWxlICE9PSAnc2hvdycpIHx8ICghZmluYWxSZXN1bHQgJiYgc2hvd1J1bGUgPT09ICdzaG93JykpIHtcbiAgICAgICAgICAgICRmaWVsZC5jb25kaXRpb25hbGx5SGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICRmaWVsZC5zZXRBdHRyaWJ1dGUoJ2RhdGEtY29uZGl0aW9uYWxseS1oaWRkZW4nLCB0cnVlKTtcblxuICAgICAgICAgICAgJGZpZWxkLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LCB0ZXh0YXJlYSwgc2VsZWN0JykuZm9yRWFjaCgoJGlucHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgJGlucHV0LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGZpZWxkLmNvbmRpdGlvbmFsbHlIaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICRmaWVsZC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtY29uZGl0aW9uYWxseS1oaWRkZW4nKTtcblxuICAgICAgICAgICAgJGZpZWxkLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LCB0ZXh0YXJlYSwgc2VsZWN0JykuZm9yRWFjaCgoJGlucHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgJGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyZSBhbiBldmVudCB0byBub3RpZnkgdGhhdCB0aGUgZmllbGQncyBjb25kaXRpb25zIGhhdmUgYmVlbiBldmFsdWF0ZWRcbiAgICAgICAgJGZpZWxkLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdvbkFmdGVyRm9ybWllRXZhbHVhdGVDb25kaXRpb25zJywgeyBidWJibGVzOiB0cnVlLCBkZXRhaWw6IHsgaW5pdDogaXNJbml0IH0gfSkpO1xuICAgIH1cblxuICAgIHBhcnNlSnNvbkNvbmRpdGlvbnMoJGZpZWxkKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSAkZmllbGQuZ2V0QXR0cmlidXRlKCdkYXRhLWZpZWxkLWNvbmRpdGlvbnMnKTtcblxuICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBVbmFibGUgdG8gcGFyc2UgSlNPTiBjb25kaXRpb25zOiAke2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0RXZlbnRUeXBlKCRmaWVsZCkge1xuICAgICAgICBjb25zdCB0YWdOYW1lID0gJGZpZWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgaW5wdXRUeXBlID0gJGZpZWxkLmdldEF0dHJpYnV0ZSgndHlwZScpID8gJGZpZWxkLmdldEF0dHJpYnV0ZSgndHlwZScpLnRvTG93ZXJDYXNlKCkgOiAnJztcblxuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ3NlbGVjdCcgfHwgaW5wdXRUeXBlID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgIHJldHVybiAnY2hhbmdlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnB1dFR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lucHV0JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnB1dFR5cGUgPT09ICdjaGVja2JveCcgfHwgaW5wdXRUeXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NsaWNrJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAna2V5dXAnO1xuICAgIH1cblxuICAgIHRlc3RDb25kaXRpb24obG9naWMsIHZhbHVlLCBmaWVsZFZhbHVlLCB0ZXN0T3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgICAvLyBBcmUgd2UgZGVhbGluZyB3aXRoIGRhdGVzPyBUaGF0J3MgYSB3aG9sZSBvdGhlciBtZXNzLi4uXG4gICAgICAgIGlmICh0ZXN0T3B0aW9ucy5pc0RhdGUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBuZXcgRGF0ZShmaWVsZFZhbHVlKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9naWMgPT09ICc9Jykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUgPT09IGZpZWxkVmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAobG9naWMgPT09ICchPScpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlICE9PSBmaWVsZFZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKGxvZ2ljID09PSAnPicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlRmxvYXQoZmllbGRWYWx1ZSwgMTApID4gcGFyc2VGbG9hdCh2YWx1ZSwgMTApO1xuICAgICAgICB9IGVsc2UgaWYgKGxvZ2ljID09PSAnPCcpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlRmxvYXQoZmllbGRWYWx1ZSwgMTApIDwgcGFyc2VGbG9hdCh2YWx1ZSwgMTApO1xuICAgICAgICB9IGVsc2UgaWYgKGxvZ2ljID09PSAnY29udGFpbnMnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmaWVsZFZhbHVlLmluY2x1ZGVzKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2dpYyA9PT0gJ3N0YXJ0c1dpdGgnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmaWVsZFZhbHVlLnN0YXJ0c1dpdGgodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGxvZ2ljID09PSAnZW5kc1dpdGgnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmaWVsZFZhbHVlLmVuZHNXaXRoKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcXVlcnlTZWxlY3RvckFsbFJlZ2V4KHJlZ2V4LCBhdHRyaWJ1dGVUb1NlYXJjaCkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy4kZm9ybS5xdWVyeVNlbGVjdG9yQWxsKGBbJHthdHRyaWJ1dGVUb1NlYXJjaH1dYCkpIHtcbiAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZVRvU2VhcmNoKSkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxufVxuXG53aW5kb3cuRm9ybWllQ29uZGl0aW9ucyA9IEZvcm1pZUNvbmRpdGlvbnM7XG4iXSwibmFtZXMiOlsiZXZlbnRLZXkiLCJGb3JtaWVDb25kaXRpb25zIiwic2V0dGluZ3MiLCIkZm9ybSIsImZvcm0iLCJjb25kaXRpb25zU3RvcmUiLCJXZWFrTWFwIiwiaW5pdEZpZWxkQ29uZGl0aW9ucyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiJGZpZWxkIiwiY29uZGl0aW9uU2V0dGluZ3MiLCJwYXJzZUpzb25Db25kaXRpb25zIiwiY29uZGl0aW9ucyIsImxlbmd0aCIsImNvbmRpdGlvbiIsIiR0YXJnZXRzIiwiZmllbGQiLCIkbXVsdGlGaWVsZHMiLCJpbmNsdWRlcyIsInJlZ2V4U3RyaW5nIiwicmVwbGFjZSIsInF1ZXJ5U2VsZWN0b3JBbGxSZWdleCIsIlJlZ0V4cCIsInB1c2giLCIkdGFyZ2V0IiwiZXZlbnRUeXBlIiwiZ2V0RXZlbnRUeXBlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsImJ1YmJsZXMiLCJzZXQiLCJzaG93UnVsZSIsImNvbmRpdGlvblJ1bGUiLCJpc05lc3RlZCIsImV2YWx1YXRlQ29uZGl0aW9ucyIsImJpbmQiLCJkZXRhaWwiLCJpbml0IiwiZm9ybVRoZW1lIiwidXBkYXRlRm9ybUhhc2giLCJlIiwidGFyZ2V0IiwiaXNJbml0IiwiZ2V0IiwicmVzdWx0cyIsImkiLCJsb2dpYyIsInZhbHVlIiwicmVzdWx0IiwidGVzdE9wdGlvbnMiLCJ0YWdOYW1lIiwidG9Mb3dlckNhc2UiLCJpbnB1dFR5cGUiLCJnZXRBdHRyaWJ1dGUiLCJyZXN1bHRLZXkiLCJpc0RhdGUiLCJ0ZXN0Q29uZGl0aW9uIiwiY2hlY2tlZCIsImhhc0F0dHJpYnV0ZSIsIkFycmF5IiwiZnJvbSIsIm9wdGlvbnMiLCIkb3B0aW9uIiwic2VsZWN0ZWQiLCJub3JtYWxpc2VkUmVzdWx0cyIsIk9iamVjdCIsInZhbHVlcyIsImZpbmFsUmVzdWx0IiwiZXZlcnkiLCJ2YWwiLCJvdmVycmlkZVJlc3VsdCIsIiRwYXJlbnRGaWVsZCIsImNsb3Nlc3QiLCJjb25kaXRpb25hbGx5SGlkZGVuIiwic2V0QXR0cmlidXRlIiwiJGlucHV0IiwicmVtb3ZlQXR0cmlidXRlIiwianNvbiIsIkpTT04iLCJwYXJzZSIsImNvbnNvbGUiLCJlcnJvciIsImZpZWxkVmFsdWUiLCJEYXRlIiwidmFsdWVPZiIsInBhcnNlRmxvYXQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJyZWdleCIsImF0dHJpYnV0ZVRvU2VhcmNoIiwib3V0cHV0IiwiZWxlbWVudCIsInRlc3QiLCJ3aW5kb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/fields/conditions.js\n");

/***/ }),

/***/ "./src/js/utils/utils.js":
/*!*******************************!*\
  !*** ./src/js/utils/utils.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"eventKey\": () => (/* binding */ eventKey),\n/* harmony export */   \"isEmpty\": () => (/* binding */ isEmpty),\n/* harmony export */   \"toBoolean\": () => (/* binding */ toBoolean)\n/* harmony export */ });\nvar isEmpty = function isEmpty(obj) {\n  return obj && Object.keys(obj).length === 0 && obj.constructor === Object;\n};\nvar toBoolean = function toBoolean(val) {\n  return !/^(?:f(?:alse)?|no?|0+)$/i.test(val) && !!val;\n};\nvar eventKey = function eventKey(eventName) {\n  var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  if (!namespace) {\n    namespace = Math.random().toString(36).substr(2, 5);\n  }\n\n  return \"\".concat(eventName, \".\").concat(namespace);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvdXRpbHMvdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQU8sSUFBTUEsT0FBTyxHQUFHLFNBQVZBLE9BQVUsQ0FBU0MsR0FBVCxFQUFjO0VBQ2pDLE9BQU9BLEdBQUcsSUFBSUMsTUFBTSxDQUFDQyxJQUFQLENBQVlGLEdBQVosRUFBaUJHLE1BQWpCLEtBQTRCLENBQW5DLElBQXdDSCxHQUFHLENBQUNJLFdBQUosS0FBb0JILE1BQW5FO0FBQ0gsQ0FGTTtBQUlBLElBQU1JLFNBQVMsR0FBRyxTQUFaQSxTQUFZLENBQVNDLEdBQVQsRUFBYztFQUNuQyxPQUFPLENBQUMsMkJBQTJCQyxJQUEzQixDQUFnQ0QsR0FBaEMsQ0FBRCxJQUF5QyxDQUFDLENBQUNBLEdBQWxEO0FBQ0gsQ0FGTTtBQUlBLElBQU1FLFFBQVEsR0FBRyxTQUFYQSxRQUFXLENBQVNDLFNBQVQsRUFBc0M7RUFBQSxJQUFsQkMsU0FBa0IsdUVBQU4sSUFBTTs7RUFDMUQsSUFBSSxDQUFDQSxTQUFMLEVBQWdCO0lBQ1pBLFNBQVMsR0FBR0MsSUFBSSxDQUFDQyxNQUFMLEdBQWNDLFFBQWQsQ0FBdUIsRUFBdkIsRUFBMkJDLE1BQTNCLENBQWtDLENBQWxDLEVBQXFDLENBQXJDLENBQVo7RUFDSDs7RUFFRCxpQkFBVUwsU0FBVixjQUF1QkMsU0FBdkI7QUFDSCxDQU5NIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3V0aWxzL3V0aWxzLmpzP2Q5ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufTtcblxuZXhwb3J0IGNvbnN0IHRvQm9vbGVhbiA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiAhL14oPzpmKD86YWxzZSk/fG5vP3wwKykkL2kudGVzdCh2YWwpICYmICEhdmFsO1xufTtcblxuZXhwb3J0IGNvbnN0IGV2ZW50S2V5ID0gZnVuY3Rpb24oZXZlbnROYW1lLCBuYW1lc3BhY2UgPSBudWxsKSB7XG4gICAgaWYgKCFuYW1lc3BhY2UpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDUpO1xuICAgIH1cblxuICAgIHJldHVybiBgJHtldmVudE5hbWV9LiR7bmFtZXNwYWNlfWA7XG59O1xuIl0sIm5hbWVzIjpbImlzRW1wdHkiLCJvYmoiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiY29uc3RydWN0b3IiLCJ0b0Jvb2xlYW4iLCJ2YWwiLCJ0ZXN0IiwiZXZlbnRLZXkiLCJldmVudE5hbWUiLCJuYW1lc3BhY2UiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/utils/utils.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/fields/conditions.js");
/******/ 	
/******/ })()
;